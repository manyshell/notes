适用于Centos 7
1、安装
yum install -y docker

2、开始服务
systemctl start docker.service

3、加入到开机启动服务
systemctl enable docker.service
如果未成功，就用旧的命令
sudo chkconfig docker on

-------------------------------------------------------------

docker列表：
https://hub.docker.com/explore/

# 查看docker版本
docker version

# 显示docker系统的信息
docker info

# 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents
$docker rmi image_name

# 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs
$docker history image_name


获取centos镜像，下载的时间和网络有关，可能会时间比较长！
docker pull centos:latest

查看镜像
docker images centos

4. 查看容器（ps）

# 列出当前所有正在运行的container
$docker ps
# 列出所有的container
$docker ps -a
# 列出最近一次启动的container
$docker ps -l
5. 保存对容器的修改（commit）

当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。

# 保存对容器的修改; -a, --author="" Author; -m, --message="" Commit message
$docker commit ID new_image_name

# 删除所有容器
$docker rm `docker ps -a -q`

# 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container
$docker rm Name/ID

# 停止、启动、杀死一个容器
$docker stop Name/ID
$docker start Name/ID
$docker kill Name/ID

# 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps
$docker logs Name/ID

# 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的
$docker diff Name/ID

# 显示一个运行的容器里面的进程信息
$docker top Name/ID

# 从容器里面拷贝文件/目录到本地一个路径
$docker cp Name:/container_path to_path
$docker cp ID:/container_path to_path

# 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10
$docker restart Name/ID

# 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process
$docker attach ID

9. 发布image（push）

# 发布docker镜像
$docker push new_image_name
10.  根据Dockerfile 构建出一个容器

#build
      --no-cache=false Do not use cache when building the image
      -q, --quiet=false Suppress the verbose output generated by the containers
      --rm=true Remove intermediate containers after a successful build
      -t, --tag="" Repository name (and optionally a tag) to be applied to the resulting image in case of success
$docker build -t image_name Dockerfile_path

docker run 指明端口有两种的方式，
一种是-P ，他是识别容器里的dockerfile声明的端口关系。 
还有一个是-p 这个是小屁屁，他就可以直白点了。  
比如 -p  6379，是对外暴露了6379。   6379:6379 是外面是6379，里面也是6379 。

# 交互式进入容器中
$docker run -i -t image_name /bin/bash

运行bash，来跑简单的测试案例！
docker run -i -t centos:latest /bin/bash
docker run -i -t ubuntu /bin/bash
docker run -d -p 22 --name="redis_test" rastasheep/ubuntu-sshd

出错了
docker run -d --name="centos:latest" /bin/bash

docker run -d -p 6379:6379 --name="centos" docker.io/centos


查看容器已经做了端口映射的端口被映射到了哪个端口上，其实直接用docker ps就能看到，使用docker port可能是为了方便二次开发
docker port

docker run -P 就是将image定好的port给做个端口映射（若没指定-p，则外部端口随机）
docker run -p "8080:80" 启动容器时候做端口映射：宿主的0.0.0.0:8080 -> 容器80
docker run -P -p "8080:80" 假如image已经有一个port 22的配置，那么就会做2个端口映射：宿主0.0.0.0:xxxxx -> 容器22、宿主0.0.0.0:8080 -> 容器80

使用docker exec 就可以进入container，例如：docker exec -it <container_id> /bin/bash

-d 参数让它后台运行

---删除---\
docker rm <容器id>
docker rmi <镜像id>

删除所有已经停止的容器
docker rm $(docker ps -a -q)

删除所有未打 dangling 标签的镜像
docker rmi $(docker images -q -f dangling=true)

---删除---/

---保存容器---\
docker commit 2cf0aedb5f0d docker.io/centos
docker commit fe59e070696f docker.io/centos

[root@395f4110e133 /]# 
2cf0aedb5f0d        =>  随系统root@395f4110e133
docker.io/centos    =>  docker images可以查到
---保存容器---/

ubuntu容器内运行着的SSH Server占用22端口，-p 22进行指定。
-p 80:8080 指的是，外部端口为80，内部端口为8080。我们ubuntu将会以8080端口运行tomcat，但对外（容器外）映射的端口为80。
docker run -d -p 22 -p 80:8080 learn/tutorial /usr/sbin/sshd -D

docker build -t myred ./
docker run -i -t centos:latest /bin/bash
docker run -it myred /bin/bash

docker run -it myred /etc/init.d/redis start

docker logs 928e7cbe9abb

//---挂载目录---\
注意，-v要写在容器名称的前面，否则会报错。
接着你在run一个Container的时候需要通过-v选项来将/mnt/sda1/dev/映射到/src目录：

docker run -i -t dev:base -v /mnt/sda1/dev:/src /bin/bash                                   //错误的写法
docker run -i -t -v /root:/mnt/download docker.io/centos /bin/bash                          //正确的写法但无缺少权限(提示Permission denied)
docker run -i -t --privileged=true -v /root:/mnt/download docker.io/centos /bin/bash        //正确的写法

//---挂载目录---/


---获取镜像---\
docker pull centos:latest
docker pull docker.io/php

---获取镜像---/

---常用操作---\
1、获取docker列表
docker search centos
docker search php
docker search lnmp

2、获取镜像
docker pull docker.io/centos                                        //操作系统
docker pull docker.io/mariadb                                       //数据库
docker pull 5kmji0bo.mirror.aliyuncs.com/library/mariadb            //加速地址
docker pull registry.aliyuncs.com/yueber/nginx-php                  //nginx/1.8.1+PHP 5.5.9-1ubuntu4.14

docker pull docker.io/domainer/centos-lnmp
docker pull registry.aliyuncs.com/max/lnmp1.2-php5.6.9-centos6.7
docker pull registry.aliyuncs.com/max/lnmp1.2-php5.6.9-centos7
docker pull registry.aliyuncs.com/freshncp/mariadb
docker pull docker.io/redis
docker pull docker.io/million12/mariadb
docker pull mariadb
docker pull registry.aliyuncs.com/com.lida/php-web

3、运行容器
A.进入到容器里面
docker run -it docker.io/centos /bin/bash
docker run -i -t --privileged=true -v /root:/mnt/download docker.io/centos /bin/bash

docker run -it docker.io/mariadb /bin/bash
docker run -it 5kmji0bo.mirror.aliyuncs.com/library/mariadb /bin/bash

docker run -i -t registry.aliyuncs.com/yueber/nginx-php /bin/bash
docker run -i -t registry.aliyuncs.com/loutian/nginx-php7 /bin/bash

docker run -i -t daocloud.io/library/nginx:1.9.14 /bin/bash
//执行成功，进入后要启动nginx
//读写
docker run -i -t --privileged=true -v /root:/usr/share/nginx/html -p 80:80 daocloud.io/library/nginx:1.9.14 /bin/bash
//只读
docker run -i -t -v /root:/usr/share/nginx/html:ro -p 80:80 daocloud.io/library/nginx:1.9.14 /bin/bash

docker run -i -t -v /root/nginx.conf:/etc/nginx/nginx.conf:ro -v /root:/usr/share/nginx/html:ro -p 80:80 daocloud.io/library/nginx:1.9.14 /bin/bash

//执行test
nginx -g 'daemon off;'
nginx -c /etc/nginx/nginx.conf
/etc/nginx/conf.d/default.conf

docker run -i -t -p 80:80 daocloud.io/library/nginx:1.9.14 /bin/bash

docker run --name nginx_server --privileged=true -v /root:/usr/share/nginx/html -p 80:80 -d daocloud.io/library/nginx:1.9.14
docker run --name nginx_server2 -p 8080:80 -d daocloud.io/library/nginx:1.9.14

docker run --name docker.io/mariadb:latest -e MYSQL_ROOT_PASSWORD=123456 -d mariadb:tag


docker run docker.io/mariadb -e MYSQL_ROOT_PASSWORD=123456 -d mariadb:yundao
docker-entrypoint.sh
/docker-entrypoint.sh mysqld_safe

docker run -it hzg/centos7:redis /bin/bash

docker run -it hzg/centos7:redis /bin/bash
docker run -i -t centos7:latest /bin/bash
docker run -i -t centos7:latest redis-server /etc/redis.conf & /bin/bash

docker run -i -t centos7:redis /bin/bash

docker run -i -t -p 6379:6379 centos7:redis     可成功进入，redis已成功开启

//---password::LNMP123---\
docker run --restart=always -e VIRTUAL_HOST=test1.test.com -P -ti --name LNMP registry.aliyuncs.com/max/lnmp1.2-php5.6.9-centos7 ./run.sh
docker run -e VIRTUAL_HOST=test1.test.com -p 80:80 -p 1022:22 -p 3306:3306 -p 6379:6379 -t -i --name LNMP registry.aliyuncs.com/max/lnmp1.2-php5.6.9-centos7 ./run.sh
docker run --restart=always -e VIRTUAL_HOST=test1.test.com -p 80:80 -p 1022:22 -p 3306:3306 -p 6379:6379 -t -i --name LNMP registry.aliyuncs.com/max/lnmp1.2-php5.6.9-centos7 ./run.sh
//---password::LNMP123---/

B.后台启动容器
//---mariadb---\
将本地目录/root/mysqldata映射到docker容器里面，内部目录为/var/lib/mysql
docker run --name mariadb_server --privileged=true -v /root/mysqldata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d 5kmji0bo.mirror.aliyuncs.com/library/mariadb
//---mariadb---/

//---nginx/1.8.1+PHP 5.5.9---\
docker run -i -t registry.aliyuncs.com/yueber/nginx-php /bin/bash
docker run --name nginx_php559 -p 80:80 -d registry.aliyuncs.com/yueber/nginx-php start.sh
//---nginx/1.8.1+PHP 5.5.9---/

docker run --name some-nginx -v /root:/usr/share/nginx/html:ro -d -p 80:80 daocloud.io/library/nginx:1.9.14

docker run -d -p 6379:6379 hzg/centos7:redis
docker run -d -p 6379:6379 centos7:redis

docker run -p 6379:6379 centos7:redis
4、启动或停止容器
此命令可以省去docker run后面的一大堆参数，相当于是恢复容器
docker start ae13b3038fdd
docker stop eaaef75e1ccf
此外，docker restart命令会将一个运行态的容器终止，然后再重新启动它。

5、重新挂载
如果容器是后台启动的，则不能挂载，会造成容器停止运行，通常start 执行后 attach
docker attach 69710ead1a43

4、保存容器
docker commit 36d9860c9159 docker.io/centos
docker commit 56de6ee3db5c hzg/centos7
docker commit 1d36ee54e8f7 hzg/php:5.6.17-fpm

5、通过Dockfile创建容器
docker build -t hzg/centos7:redis .
docker build -t centos7:redis .

6、看日志
docker logs -f f710131517dd
docker ps -a --no-trunc

7、删除
docker rm <容器id>
docker rmi <镜像id>

删除所有已经停止的容器
docker rm $(docker ps -a -q)

删除所有未打 dangling 标签的镜像
docker rmi $(docker images -q -f dangling=true)
docker rmi 6c60e8979223

8、导入与导出
导出镜像：
docker save -o centos7.tar.gz docker.io/centos
docker save -o mariadb.tar.gz 5kmji0bo.mirror.aliyuncs.com/library/mariadb
docker save -o hzg_php_5.6.17-fpm.tar.gz hzg/php:5.6.17-fpm
docker save -o daocloud_nginx_1.9.14.tar.gz daocloud.io/library/nginx:1.9.14
docker save -o redis_3.0.2.tar.gz docker.io/redis:latest
docker save -o php_7.0.0RC8-fpm.tar.gz daocloud.io/library/php:7.0.0RC8-fpm
docker save -o hzg_php_7.0.0RC8-fpm.tar.gz hzg/php:7.0.0RC8-fpm
docker save -o jira_6.4.9.tar.gz cptactionhank/atlassian-jira:6.4.9

导入镜像：
docker load --input centos7.tar.gz
docker load --input redis_3.0.2.tar.gz

导出容器：
docker export 815aaacf8612 > hzg_php_7.0.0RC8-fpm.tar.gz        //save -o出错，这样却导出来了

docker export 1a2c78a5ea0e > redis_3.0.2.tar.gz
docker export 6c5563 > ubuntu_tomcat.tar.gz

6c5563是容器的id，可以用docer ps -a 命令查看。
导入容器：???
cat exp_centcommit.tar | docker import - impcentos:v1.0.0
impcentos:v1.0.0是新的镜像名称


警告：
Usage of loopback devices is strongly discouraged for production use. Either use `--storage-opt dm.thinpooldev` or use `--storage-opt dm.no_warn_on_loop_devices=true` to suppress this warning
vi /etc/sysconfig/docker-storage